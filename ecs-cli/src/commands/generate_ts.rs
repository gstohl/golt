//! Generate TypeScript bindings

use anyhow::Result;
use heck::{ToLowerCamelCase, ToUpperCamelCase};
use std::fs;

use crate::config::GoltConfig;
use crate::parser::{self, ParsedComponent, ParsedField, ParsedInstruction};

pub fn run(output_dir: &str) -> Result<()> {
    let (config, project_root) = GoltConfig::find_config()?;

    println!("Generating TypeScript bindings to: {}", output_dir);

    let output_path = project_root.join(output_dir);
    fs::create_dir_all(&output_path)?;

    let mut exports = Vec::new();

    // Generate component bindings
    for component in &config.components {
        let component_dir = project_root
            .join(&config.project.components_dir)
            .join(&component.name);

        let state_path = component_dir.join("src/state.rs");
        let instruction_path = component_dir.join("src/instruction.rs");

        let parsed = if state_path.exists() {
            parser::parse_component_state(&state_path).ok()
        } else {
            None
        };

        let instructions = if instruction_path.exists() {
            parser::parse_component_instructions(&instruction_path).unwrap_or_default()
        } else {
            Vec::new()
        };

        let filename = format!("{}.ts", component.name);
        let content = generate_component_ts(component, parsed.as_ref(), &instructions);
        fs::write(output_path.join(&filename), content)?;
        exports.push(format!("export * from './{}';", component.name));
        println!("  Generated: {}", filename);
    }

    // Generate system bindings
    for system in &config.systems {
        let system_dir = project_root
            .join(&config.project.systems_dir)
            .join(&system.name);

        let instruction_path = system_dir.join("src/instruction.rs");

        let instructions = if instruction_path.exists() {
            parser::parse_component_instructions(&instruction_path).unwrap_or_default()
        } else {
            Vec::new()
        };

        let filename = format!("{}.ts", system.name);
        let content = generate_system_ts(system, &instructions);
        fs::write(output_path.join(&filename), content)?;
        exports.push(format!("export * from './{}';", system.name));
        println!("  Generated: {}", filename);
    }

    // Generate index.ts
    exports.push("export * from './common';".to_string());
    let index_content = exports.join("\n") + "\n";
    fs::write(output_path.join("index.ts"), index_content)?;
    println!("  Generated: index.ts");

    // Generate common types
    let common_content = generate_common_ts();
    fs::write(output_path.join("common.ts"), common_content)?;
    println!("  Generated: common.ts");

    println!();
    println!("TypeScript bindings generated successfully!");
    println!("Import with: import {{ ... }} from './{}'", output_dir);

    Ok(())
}

fn generate_component_ts(
    component: &crate::config::ComponentConfig,
    parsed: Option<&ParsedComponent>,
    instructions: &[ParsedInstruction],
) -> String {
    let pascal_name = component.name.to_upper_camel_case();
    let upper_name = component.name.to_uppercase();

    let program_id = component
        .program_id
        .as_deref()
        .unwrap_or("11111111111111111111111111111111");

    let discriminator = seed_to_discriminator(&component.seed);

    // Generate interface fields
    let interface_fields = if let Some(p) = parsed {
        p.fields
            .iter()
            .filter(|f| !f.is_discriminator)
            .map(|f| format!("  {}: {};", f.name, f.ts_type))
            .collect::<Vec<_>>()
            .join("\n")
    } else {
        "  // TODO: Add fields based on state.rs".to_string()
    };

    // Generate parse function body
    let parse_body = if let Some(p) = parsed {
        generate_parse_body(&p.fields)
    } else {
        "  throw new Error('Not implemented - update based on state.rs');".to_string()
    };

    // Generate size constant
    let size = if let Some(p) = parsed {
        p.fields.iter().map(|f| f.size).sum::<usize>()
    } else {
        0
    };

    // Generate instruction builders
    let instruction_builders = instructions
        .iter()
        .map(|i| generate_instruction_builder(&pascal_name, &upper_name, i))
        .collect::<Vec<_>>()
        .join("\n\n");

    format!(
        r#"// Auto-generated by Golt - DO NOT EDIT
import {{
  PublicKey,
  TransactionInstruction,
  SystemProgram,
  Connection,
  AccountInfo,
}} from '@solana/web3.js';
import {{ readU8, readU16, readU32, readU64, readI64, readPubkey, writeU8, writeU16, writeU32, writeU64, writePubkey }} from './common';

// Program ID
export const {upper_name}_PROGRAM_ID = new PublicKey('{program_id}');

// Constants
export const {upper_name}_SEED = '{seed}';
export const {upper_name}_DISCRIMINATOR = new Uint8Array({discriminator:?});
export const {upper_name}_SIZE = {size};

// Component interface
export interface {pascal_name} {{
{interface_fields}
}}

// PDA Derivation
export function derive{pascal_name}PDA(
  entity: PublicKey,
  programId: PublicKey = {upper_name}_PROGRAM_ID
): [PublicKey, number] {{
  return PublicKey.findProgramAddressSync(
    [Buffer.from({upper_name}_SEED), entity.toBuffer()],
    programId
  );
}}

// Parse component from account data
export function parse{pascal_name}(data: Buffer | Uint8Array): {pascal_name} {{
  const buf = Buffer.from(data);

  // Verify discriminator
  const disc = buf.subarray(0, 8);
  if (!disc.equals(Buffer.from({upper_name}_DISCRIMINATOR))) {{
    throw new Error('Invalid discriminator for {pascal_name}');
  }}

{parse_body}
}}

// Fetch component from chain
export async function fetch{pascal_name}(
  connection: Connection,
  address: PublicKey
): Promise<{pascal_name} | null> {{
  const account = await connection.getAccountInfo(address);
  if (!account) return null;
  return parse{pascal_name}(account.data);
}}

// Fetch component by entity
export async function fetch{pascal_name}ByEntity(
  connection: Connection,
  entity: PublicKey,
  programId: PublicKey = {upper_name}_PROGRAM_ID
): Promise<{pascal_name} | null> {{
  const [pda] = derive{pascal_name}PDA(entity, programId);
  return fetch{pascal_name}(connection, pda);
}}

// Instruction builders
{instruction_builders}
"#,
        upper_name = upper_name,
        pascal_name = pascal_name,
        program_id = program_id,
        seed = component.seed,
        discriminator = discriminator,
        size = size,
        interface_fields = interface_fields,
        parse_body = parse_body,
        instruction_builders = instruction_builders,
    )
}

fn generate_parse_body(fields: &[ParsedField]) -> String {
    let mut lines = Vec::new();
    let mut offset = 8usize; // Skip discriminator

    for field in fields {
        if field.is_discriminator {
            continue;
        }

        let read_expr = match field.rust_type.as_str() {
            "u8" => format!("readU8(buf, {})", offset),
            "u16" => format!("readU16(buf, {})", offset),
            "u32" => format!("readU32(buf, {})", offset),
            "u64" => format!("readU64(buf, {})", offset),
            "i64" => format!("readI64(buf, {})", offset),
            "bool" => format!("readU8(buf, {}) !== 0", offset),
            "Pubkey" | "[u8;32]" => format!("readPubkey(buf, {})", offset),
            s if s.starts_with("[u8;") => {
                format!("buf.subarray({}, {})", offset, offset + field.size)
            }
            _ => format!("buf.subarray({}, {}) /* {} */", offset, offset + field.size, field.rust_type),
        };

        lines.push(format!("  const {} = {};", field.name, read_expr));
        offset += field.size;
    }

    // Return statement
    let field_names: Vec<_> = fields
        .iter()
        .filter(|f| !f.is_discriminator)
        .map(|f| format!("    {},", f.name))
        .collect();

    lines.push(String::new());
    lines.push("  return {".to_string());
    lines.extend(field_names);
    lines.push("  };".to_string());

    lines.join("\n")
}

fn generate_instruction_builder(
    pascal_name: &str,
    upper_name: &str,
    instruction: &ParsedInstruction,
) -> String {
    let fn_name = instruction.name.to_lower_camel_case();
    let tag = instruction.tag;

    // Generate parameters
    let params: Vec<String> = instruction
        .params
        .iter()
        .map(|p| format!("{}: {}", p.name, p.ts_type))
        .collect();

    // Generate account params
    let account_params: Vec<String> = instruction
        .accounts
        .iter()
        .map(|a| format!("{}: PublicKey", a.name))
        .collect();

    let all_params = [account_params.clone(), params.clone()].concat();
    let params_str = if all_params.is_empty() {
        "programId: PublicKey = {}_PROGRAM_ID".replace("{}", upper_name)
    } else {
        format!(
            "{},\n  programId: PublicKey = {}_PROGRAM_ID",
            all_params.join(",\n  "),
            upper_name
        )
    };

    // Generate data buffer
    let data_size = 1 + instruction.params.iter().map(|p| param_size(&p.rust_type)).sum::<usize>();
    let data_writes = generate_data_writes(&instruction.params);

    // Generate keys array
    let keys: Vec<String> = instruction
        .accounts
        .iter()
        .map(|a| {
            format!(
                "    {{ pubkey: {}, isSigner: {}, isWritable: {} }}",
                a.name, a.is_signer, a.is_writable
            )
        })
        .collect();
    let keys_str = if keys.is_empty() {
        "[]".to_string()
    } else {
        format!("[\n{},\n  ]", keys.join(",\n"))
    };

    format!(
        r#"export function create{pascal_name}{fn_name}Instruction(
  {params_str}
): TransactionInstruction {{
  const data = Buffer.alloc({data_size});
  data.writeUInt8({tag}, 0);
{data_writes}
  return new TransactionInstruction({{
    programId,
    keys: {keys_str},
    data,
  }});
}}"#,
        pascal_name = pascal_name,
        fn_name = fn_name,
        params_str = params_str,
        data_size = data_size,
        tag = tag,
        data_writes = data_writes,
        keys_str = keys_str,
    )
}

fn generate_data_writes(params: &[crate::parser::ParsedParam]) -> String {
    let mut lines = Vec::new();
    let mut offset = 1usize; // Skip tag byte

    for param in params {
        let write_expr = match param.rust_type.as_str() {
            "u8" => format!("  data.writeUInt8({}, {});", param.name, offset),
            "u16" => format!("  data.writeUInt16LE({}, {});", param.name, offset),
            "u32" => format!("  data.writeUInt32LE({}, {});", param.name, offset),
            "u64" => format!("  data.writeBigUInt64LE(BigInt({}), {});", param.name, offset),
            "i64" => format!("  data.writeBigInt64LE(BigInt({}), {});", param.name, offset),
            "bool" => format!("  data.writeUInt8({} ? 1 : 0, {});", param.name, offset),
            "Pubkey" | "[u8;32]" => format!("  {}.toBuffer().copy(data, {});", param.name, offset),
            _ => format!("  // TODO: write {} at offset {}", param.name, offset),
        };
        lines.push(write_expr);
        offset += param_size(&param.rust_type);
    }

    lines.join("\n")
}

fn param_size(rust_type: &str) -> usize {
    match rust_type {
        "u8" | "i8" | "bool" => 1,
        "u16" | "i16" => 2,
        "u32" | "i32" => 4,
        "u64" | "i64" => 8,
        "u128" | "i128" => 16,
        "Pubkey" | "[u8;32]" => 32,
        _ => 0,
    }
}

fn seed_to_discriminator(seed: &str) -> Vec<u8> {
    let mut disc = seed.as_bytes().to_vec();
    disc.resize(8, 0);
    disc
}

fn generate_system_ts(
    system: &crate::config::SystemConfig,
    instructions: &[ParsedInstruction],
) -> String {
    let pascal_name = system.name.to_upper_camel_case();
    let upper_name = system.name.to_uppercase();

    let program_id = system
        .program_id
        .as_deref()
        .unwrap_or("11111111111111111111111111111111");

    // Generate instruction builders
    let instruction_builders = instructions
        .iter()
        .map(|i| generate_instruction_builder(&pascal_name, &upper_name, i))
        .collect::<Vec<_>>()
        .join("\n\n");

    let instruction_builders = if instruction_builders.is_empty() {
        "// TODO: Add instruction builders based on instruction.rs".to_string()
    } else {
        instruction_builders
    };

    format!(
        r#"// Auto-generated by Golt - DO NOT EDIT
import {{
  PublicKey,
  TransactionInstruction,
  SystemProgram,
}} from '@solana/web3.js';
import {{ writeU8, writeU16, writeU32, writeU64, writePubkey }} from './common';

// Program ID
export const {upper_name}_PROGRAM_ID = new PublicKey('{program_id}');

// Instruction builders
{instruction_builders}
"#,
        upper_name = upper_name,
        program_id = program_id,
        instruction_builders = instruction_builders,
    )
}

fn generate_common_ts() -> String {
    r#"// Auto-generated by Golt - DO NOT EDIT
import { PublicKey, Connection } from '@solana/web3.js';

// Buffer reading utilities (little-endian)

export function readU8(data: Buffer, offset: number): number {
  return data.readUInt8(offset);
}

export function readU16(data: Buffer, offset: number): number {
  return data.readUInt16LE(offset);
}

export function readU32(data: Buffer, offset: number): number {
  return data.readUInt32LE(offset);
}

export function readU64(data: Buffer, offset: number): bigint {
  return data.readBigUInt64LE(offset);
}

export function readI8(data: Buffer, offset: number): number {
  return data.readInt8(offset);
}

export function readI16(data: Buffer, offset: number): number {
  return data.readInt16LE(offset);
}

export function readI32(data: Buffer, offset: number): number {
  return data.readInt32LE(offset);
}

export function readI64(data: Buffer, offset: number): bigint {
  return data.readBigInt64LE(offset);
}

export function readBool(data: Buffer, offset: number): boolean {
  return data.readUInt8(offset) !== 0;
}

export function readPubkey(data: Buffer, offset: number): PublicKey {
  return new PublicKey(data.subarray(offset, offset + 32));
}

export function readBytes(data: Buffer, offset: number, length: number): Uint8Array {
  return new Uint8Array(data.subarray(offset, offset + length));
}

// Buffer writing utilities (little-endian)

export function writeU8(data: Buffer, offset: number, value: number): void {
  data.writeUInt8(value, offset);
}

export function writeU16(data: Buffer, offset: number, value: number): void {
  data.writeUInt16LE(value, offset);
}

export function writeU32(data: Buffer, offset: number, value: number): void {
  data.writeUInt32LE(value, offset);
}

export function writeU64(data: Buffer, offset: number, value: bigint | number): void {
  data.writeBigUInt64LE(BigInt(value), offset);
}

export function writeI8(data: Buffer, offset: number, value: number): void {
  data.writeInt8(value, offset);
}

export function writeI16(data: Buffer, offset: number, value: number): void {
  data.writeInt16LE(value, offset);
}

export function writeI32(data: Buffer, offset: number, value: number): void {
  data.writeInt32LE(value, offset);
}

export function writeI64(data: Buffer, offset: number, value: bigint | number): void {
  data.writeBigInt64LE(BigInt(value), offset);
}

export function writeBool(data: Buffer, offset: number, value: boolean): void {
  data.writeUInt8(value ? 1 : 0, offset);
}

export function writePubkey(data: Buffer, offset: number, value: PublicKey): void {
  value.toBuffer().copy(data, offset);
}

export function writeBytes(data: Buffer, offset: number, value: Uint8Array): void {
  Buffer.from(value).copy(data, offset);
}

// Utility to check discriminator
export function checkDiscriminator(
  data: Buffer | Uint8Array,
  expected: Uint8Array
): boolean {
  const disc = data.slice(0, 8);
  for (let i = 0; i < 8; i++) {
    if (disc[i] !== expected[i]) return false;
  }
  return true;
}
"#.to_string()
}
