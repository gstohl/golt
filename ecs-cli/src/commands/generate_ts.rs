//! Generate TypeScript bindings

use anyhow::Result;
use heck::{ToLowerCamelCase, ToUpperCamelCase};
use std::fs;

use crate::config::GoltConfig;

pub fn run(output_dir: &str) -> Result<()> {
    let (config, project_root) = GoltConfig::find_config()?;

    println!("Generating TypeScript bindings to: {}", output_dir);

    let output_path = project_root.join(output_dir);
    fs::create_dir_all(&output_path)?;

    // Generate index.ts
    let mut exports = Vec::new();

    // Generate component bindings
    for component in &config.components {
        let filename = format!("{}.ts", component.name);
        let content = generate_component_ts(component);
        fs::write(output_path.join(&filename), content)?;
        exports.push(format!("export * from './{}';", component.name));
        println!("  Generated: {}", filename);
    }

    // Generate system bindings
    for system in &config.systems {
        let filename = format!("{}.ts", system.name);
        let content = generate_system_ts(system);
        fs::write(output_path.join(&filename), content)?;
        exports.push(format!("export * from './{}';", system.name));
        println!("  Generated: {}", filename);
    }

    // Generate index.ts
    let index_content = exports.join("\n") + "\n";
    fs::write(output_path.join("index.ts"), index_content)?;
    println!("  Generated: index.ts");

    // Generate common types
    let common_content = generate_common_ts();
    fs::write(output_path.join("common.ts"), common_content)?;
    println!("  Generated: common.ts");

    println!();
    println!("TypeScript bindings generated successfully!");
    println!("Import with: import {{ ... }} from './{}'", output_dir);

    Ok(())
}

fn generate_component_ts(component: &crate::config::ComponentConfig) -> String {
    let pascal_name = component.name.to_upper_camel_case();
    let camel_name = component.name.to_lower_camel_case();
    let upper_name = component.name.to_uppercase();

    let program_id = component
        .program_id
        .as_deref()
        .unwrap_or("YOUR_PROGRAM_ID_HERE");

    format!(
        r#"// Auto-generated by Golt - DO NOT EDIT
import {{ PublicKey, TransactionInstruction, SystemProgram }} from '@solana/web3.js';

// Program ID
export const {upper_name}_PROGRAM_ID = new PublicKey('{program_id}');

// Constants
export const {upper_name}_SEED = '{seed}';
export const {upper_name}_DISCRIMINATOR = Buffer.from({discriminator:?});

// TODO: Define your component interface based on state.rs
export interface {pascal_name} {{
  // Add fields here
}}

// PDA Derivation
export function derive{pascal_name}PDA(entity: PublicKey): [PublicKey, number] {{
  return PublicKey.findProgramAddressSync(
    [Buffer.from({upper_name}_SEED), entity.toBuffer()],
    {upper_name}_PROGRAM_ID
  );
}}

// TODO: Add parse function based on your state layout
export function parse{pascal_name}(data: Buffer): {pascal_name} {{
  // Implement parsing based on state.rs
  throw new Error('Not implemented - update based on state.rs');
}}

// TODO: Add instruction builders based on instruction.rs
"#,
        upper_name = upper_name,
        pascal_name = pascal_name,
        program_id = program_id,
        seed = component.seed,
        discriminator = component.seed.as_bytes().iter().take(8).cloned().collect::<Vec<_>>(),
    )
}

fn generate_system_ts(system: &crate::config::SystemConfig) -> String {
    let pascal_name = system.name.to_upper_camel_case();
    let upper_name = system.name.to_uppercase();

    let program_id = system
        .program_id
        .as_deref()
        .unwrap_or("YOUR_PROGRAM_ID_HERE");

    format!(
        r#"// Auto-generated by Golt - DO NOT EDIT
import {{ PublicKey, TransactionInstruction }} from '@solana/web3.js';

// Program ID
export const {upper_name}_PROGRAM_ID = new PublicKey('{program_id}');

// TODO: Add instruction builders based on instruction.rs
"#,
        upper_name = upper_name,
        program_id = program_id,
    )
}

fn generate_common_ts() -> String {
    r#"// Auto-generated by Golt - DO NOT EDIT
import { PublicKey, Connection } from '@solana/web3.js';

// Common utilities for parsing account data

export function readU8(data: Buffer, offset: number): number {
  return data.readUInt8(offset);
}

export function readU16(data: Buffer, offset: number): number {
  return data.readUInt16LE(offset);
}

export function readU32(data: Buffer, offset: number): number {
  return data.readUInt32LE(offset);
}

export function readU64(data: Buffer, offset: number): bigint {
  return data.readBigUInt64LE(offset);
}

export function readI64(data: Buffer, offset: number): bigint {
  return data.readBigInt64LE(offset);
}

export function readPubkey(data: Buffer, offset: number): PublicKey {
  return new PublicKey(data.subarray(offset, offset + 32));
}

export function writeU8(data: Buffer, offset: number, value: number): void {
  data.writeUInt8(value, offset);
}

export function writeU16(data: Buffer, offset: number, value: number): void {
  data.writeUInt16LE(value, offset);
}

export function writeU32(data: Buffer, offset: number, value: number): void {
  data.writeUInt32LE(value, offset);
}

export function writeU64(data: Buffer, offset: number, value: bigint): void {
  data.writeBigUInt64LE(value, offset);
}

export function writePubkey(data: Buffer, offset: number, value: PublicKey): void {
  data.set(value.toBuffer(), offset);
}
"#.to_string()
}
